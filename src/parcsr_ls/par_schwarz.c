/******************************************************************************
 * Copyright (c) 1998 Lawrence Livermore National Security, LLC and other
 * HYPRE Project Developers. See the top-level COPYRIGHT file for details.
 *
 * SPDX-License-Identifier: (Apache-2.0 OR MIT)
 ******************************************************************************/

/******************************************************************************
 *
 * Schwarz functions
 *
 *****************************************************************************/

#include "_hypre_parcsr_ls.h"
#include "schwarz.h"

/*--------------------------------------------------------------------------
 * hypre_SchwarzCreate
 *--------------------------------------------------------------------------*/

void *
hypre_SchwarzCreate( void )
{
   hypre_SchwarzData *schwarz_data;

   HYPRE_Int      variant;
   HYPRE_Int      domain_type;
   HYPRE_Int      overlap;
   HYPRE_Int      num_functions;
   HYPRE_Int      use_nonsymm;
   HYPRE_Real     relax_weight;

   /*-----------------------------------------------------------------------
    * Setup default values for parameters
    *-----------------------------------------------------------------------*/

   /* setup params */
   variant = 0;  /* multiplicative Schwarz */
   overlap = 1;  /* minimal overlap */
   domain_type = 2; /* domains generated by agglomeration */
   num_functions = 1;
   use_nonsymm = 0;
   relax_weight = 1.0;

   schwarz_data = hypre_CTAlloc(hypre_SchwarzData, 1, HYPRE_MEMORY_HOST);

   hypre_SchwarzSetVariant(schwarz_data, variant);
   hypre_SchwarzSetDomainType(schwarz_data, domain_type);
   hypre_SchwarzSetOverlap(schwarz_data, overlap);
   hypre_SchwarzSetNumFunctions(schwarz_data, num_functions);
   hypre_SchwarzSetNonSymm(schwarz_data, use_nonsymm);
   hypre_SchwarzSetRelaxWeight(schwarz_data, relax_weight);

   hypre_SchwarzDataDomainStructure(schwarz_data) = NULL;
   hypre_SchwarzDataABoundary(schwarz_data) = NULL;
   hypre_SchwarzDataScale(schwarz_data) = NULL;
   hypre_SchwarzDataVtemp(schwarz_data) = NULL;
   hypre_SchwarzDataDofFunc(schwarz_data) = NULL;

   /* FLOP and graph op counting */
   hypre_SchwarzDataSetupFlops(schwarz_data) = 0.0;
   hypre_SchwarzDataSetupGraphOps(schwarz_data) = 0.0;
   hypre_SchwarzDataApplyFlops(schwarz_data) = 0.0;

   return (void *) schwarz_data;
}

/*--------------------------------------------------------------------------
 * hypre_SchwarzDestroy
 *--------------------------------------------------------------------------*/

HYPRE_Int
hypre_SchwarzDestroy( void *data )
{
   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   if (hypre_SchwarzDataScale(schwarz_data))
   {
      hypre_TFree(hypre_SchwarzDataScale(schwarz_data), HYPRE_MEMORY_HOST);
   }
   if (hypre_SchwarzDataDofFunc(schwarz_data))
   {
      hypre_TFree(hypre_SchwarzDataDofFunc(schwarz_data), HYPRE_MEMORY_HOST);
   }
   hypre_CSRMatrixDestroy(hypre_SchwarzDataDomainStructure(schwarz_data));
   if (hypre_SchwarzDataVariant(schwarz_data) == 3)
   {
      hypre_CSRMatrixDestroy(hypre_SchwarzDataABoundary(schwarz_data));
   }
   hypre_ParVectorDestroy(hypre_SchwarzDataVtemp(schwarz_data));

   if (hypre_SchwarzDataPivots(schwarz_data))
   {
      hypre_TFree(hypre_SchwarzDataPivots(schwarz_data), HYPRE_MEMORY_HOST);
   }


   hypre_TFree(schwarz_data, HYPRE_MEMORY_HOST);
   return hypre_error_flag;

}

HYPRE_Int
hypre_SchwarzSetup(void               *schwarz_vdata,
                   hypre_ParCSRMatrix *A,
                   hypre_ParVector    *f,
                   hypre_ParVector    *u)
{
   HYPRE_UNUSED_VAR(f);
   HYPRE_UNUSED_VAR(u);

   hypre_SchwarzData   *schwarz_data = (hypre_SchwarzData*) schwarz_vdata;
   HYPRE_Int *dof_func;
   HYPRE_Real *scale;
   hypre_CSRMatrix *domain_structure;
   hypre_CSRMatrix *A_boundary;
   hypre_ParVector *Vtemp;

   HYPRE_Int *pivots = NULL;

   HYPRE_Int variant = hypre_SchwarzDataVariant(schwarz_data);
   HYPRE_Int domain_type = hypre_SchwarzDataDomainType(schwarz_data);
   HYPRE_Int overlap = hypre_SchwarzDataOverlap(schwarz_data);
   HYPRE_Int num_functions = hypre_SchwarzDataNumFunctions(schwarz_data);
   HYPRE_Real relax_weight = hypre_SchwarzDataRelaxWeight(schwarz_data);
   HYPRE_Int use_nonsymm = hypre_SchwarzDataUseNonSymm(schwarz_data);


   dof_func = hypre_SchwarzDataDofFunc(schwarz_data);

   Vtemp = hypre_ParVectorCreate(hypre_ParCSRMatrixComm(A),
                                 hypre_ParCSRMatrixGlobalNumRows(A),
                                 hypre_ParCSRMatrixRowStarts(A));
   hypre_ParVectorInitialize(Vtemp);
   hypre_SchwarzDataVtemp(schwarz_data) = Vtemp;

   if (variant > 1)
   {
      hypre_ParAMGCreateDomainDof(A,
                                  domain_type, overlap,
                                  num_functions, dof_func,
                                  &domain_structure, &pivots, use_nonsymm);

      if (domain_structure)
      {
         if (variant == 2)
         {
            hypre_ParGenerateScale(A, domain_structure, relax_weight,
                                   &scale);
            hypre_SchwarzDataScale(schwarz_data) = scale;
         }
         else
         {
            hypre_ParGenerateHybridScale(A, domain_structure, &A_boundary, &scale);
            hypre_SchwarzDataScale(schwarz_data) = scale;
            if (hypre_CSRMatrixNumCols(hypre_ParCSRMatrixOffd(A)))
            {
               hypre_SchwarzDataABoundary(schwarz_data) = A_boundary;
            }
            else
            {
               hypre_SchwarzDataABoundary(schwarz_data) = NULL;
            }
         }
      }
   }
   else
   {
      hypre_AMGCreateDomainDof (hypre_ParCSRMatrixDiag(A),
                                domain_type, overlap,
                                num_functions, dof_func,
                                &domain_structure, &pivots, use_nonsymm);
      if (domain_structure)
      {
         if (variant == 1)
         {
            hypre_GenerateScale(domain_structure,
                                hypre_CSRMatrixNumRows(hypre_ParCSRMatrixDiag(A)),
                                relax_weight, &scale);
            hypre_SchwarzDataScale(schwarz_data) = scale;
         }
      }
   }

   hypre_SchwarzDataDomainStructure(schwarz_data) = domain_structure;
   hypre_SchwarzDataPivots(schwarz_data) = pivots;

   /* Compute FLOP, graph op, and apply cost for Schwarz.
    * These are the authoritative values; AMG setup reads them when
    * Schwarz is used as a smoother. */
   if (domain_structure)
   {
      HYPRE_Int num_domains = hypre_CSRMatrixNumRows(domain_structure);
      HYPRE_Int *domain_i = hypre_CSRMatrixI(domain_structure);
      HYPRE_Real nnz_A = (HYPRE_Real)(hypre_CSRMatrixNumNonzeros(hypre_ParCSRMatrixDiag(A)) +
                                      hypre_CSRMatrixNumNonzeros(hypre_ParCSRMatrixOffd(A)));
      HYPRE_Real n_A = (HYPRE_Real) hypre_ParCSRMatrixGlobalNumRows(A);
      HYPRE_Real sum_di = 0.0, sum_di2 = 0.0, sum_di3 = 0.0;
      HYPRE_Int d;

      for (d = 0; d < num_domains; d++)
      {
         HYPRE_Real di = (HYPRE_Real)(domain_i[d + 1] - domain_i[d]);
         sum_di  += di;
         sum_di2 += di * di;
         sum_di3 += di * di * di;
      }

      /* Setup: factorization cost.
       * Cholesky (symmetric, variant 0/1): d_i^3/6 per domain.
       * LU (nonsymmetric, variant 2/3):    d_i^3/3 per domain. */
      {
         HYPRE_Real fact_coeff = use_nonsymm ? (1.0 / 3.0) : (1.0 / 6.0);
         hypre_SchwarzDataSetupFlops(schwarz_data) = fact_coeff * sum_di3;
      }

      /* Setup: graph ops for domain construction and extraction */
      {
         HYPRE_Real graph_cost = 0.0;

         /* Extraction: each domain scans A rows for its DOFs */
         if (n_A > 0.0)
         {
            graph_cost += sum_di * nnz_A / n_A;
         }

         if (domain_type == 2)
         {
            /* Agglomeration: 4*nnz(A) + AE search */
            graph_cost += 4.0 * nnz_A;
            if (overlap == 1 && num_domains > 0)
            {
               HYPRE_Real avg_ovlp = (sum_di - n_A) / (HYPRE_Real) num_domains;
               HYPRE_Real sum_si2 = sum_di2 - 2.0 * avg_ovlp * sum_di
                                    + avg_ovlp * avg_ovlp * (HYPRE_Real) num_domains;
               graph_cost += sum_si2 * nnz_A / n_A;
            }
            else if (n_A > 0.0)
            {
               /* No overlap: s_i = d_i */
               graph_cost += sum_di2 * nnz_A / n_A;
            }
         }

         if (overlap == 1)
         {
            /* Overlap extension: 4*nnz(A) */
            graph_cost += 4.0 * nnz_A;
         }

         hypre_SchwarzDataSetupGraphOps(schwarz_data) = graph_cost;
      }

      /* Apply cost per solve application.
       * Dense triangular solve: dpotrs/dgetrs = 2*d_i^2 FMAs per domain per call.
       * Residual computation per domain per sweep:
       *   Multiplicative (0, 3, 4): per-domain sparse residual ~ sum(d_i)*nnz(A)/n
       *   Additive (1, 2): one global matvec = nnz(A)
       * Multiplicative variants (0, 3): forward + backward sweep = 2 sweeps.
       * Others (1, 2, 4): single sweep. */
      {
         HYPRE_Int num_sweeps = (variant == 0 || variant == 3) ? 2 : 1;
         HYPRE_Real solve_cost = 2.0 * (HYPRE_Real) num_sweeps * sum_di2;
         HYPRE_Real residual_cost = 0.0;

         if (variant == 0 || variant == 3 || variant == 4)
         {
            /* Per-domain sparse residual: each DOF scans its row in A */
            if (n_A > 0.0)
            {
               residual_cost = (HYPRE_Real) num_sweeps * sum_di * nnz_A / n_A;
            }
         }
         else
         {
            /* Additive: one global matvec */
            residual_cost = nnz_A;
         }

         hypre_SchwarzDataApplyFlops(schwarz_data) = solve_cost + residual_cost;
      }
   }
   else
   {
      hypre_SchwarzDataSetupFlops(schwarz_data) = 0.0;
      hypre_SchwarzDataSetupGraphOps(schwarz_data) = 0.0;
      hypre_SchwarzDataApplyFlops(schwarz_data) = 0.0;
   }

   return hypre_error_flag;

}

/*--------------------------------------------------------------------
 * hypre_SchwarzSolve
 *--------------------------------------------------------------------*/

HYPRE_Int
hypre_SchwarzSolve(void               *schwarz_vdata,
                   hypre_ParCSRMatrix *A,
                   hypre_ParVector    *f,
                   hypre_ParVector    *u         )
{
   hypre_SchwarzData   *schwarz_data = (hypre_SchwarzData*) schwarz_vdata;

   hypre_CSRMatrix *domain_structure =
      hypre_SchwarzDataDomainStructure(schwarz_data);
   hypre_CSRMatrix *A_boundary = hypre_SchwarzDataABoundary(schwarz_data);
   HYPRE_Real *scale = hypre_SchwarzDataScale(schwarz_data);
   hypre_ParVector *Vtemp = hypre_SchwarzDataVtemp(schwarz_data);
   HYPRE_Int variant = hypre_SchwarzDataVariant(schwarz_data);
   HYPRE_Real relax_wt = hypre_SchwarzDataRelaxWeight(schwarz_data);
   HYPRE_Int use_nonsymm = hypre_SchwarzDataUseNonSymm(schwarz_data);

   HYPRE_Int *pivots = hypre_SchwarzDataPivots(schwarz_data);

   if (domain_structure)
   {
      if (variant == 2)
      {
         hypre_ParAdSchwarzSolve(A, f, domain_structure, scale, u, Vtemp, pivots, use_nonsymm);
      }
      else if (variant == 3)
      {
         hypre_ParMPSchwarzSolve(A, A_boundary, f, domain_structure, u,
                                 relax_wt, scale, Vtemp, pivots, use_nonsymm);
      }
      else if (variant == 1)
      {
         hypre_AdSchwarzSolve(A, f, domain_structure, scale, u, Vtemp, pivots, use_nonsymm);
      }
      else if (variant == 4)
      {
         hypre_MPSchwarzFWSolve(A, hypre_ParVectorLocalVector(f),
                                domain_structure, u, relax_wt,
                                hypre_ParVectorLocalVector(Vtemp), pivots, use_nonsymm);
      }
      else
      {
         hypre_MPSchwarzSolve(A, hypre_ParVectorLocalVector(f),
                              domain_structure, u, relax_wt,
                              hypre_ParVectorLocalVector(Vtemp), pivots, use_nonsymm);
      }
   }

   return hypre_error_flag;
}
/*--------------------------------------------------------------------
 * hypre_SchwarzCFSolve
 *--------------------------------------------------------------------*/

HYPRE_Int
hypre_SchwarzCFSolve(void               *schwarz_vdata,
                     hypre_ParCSRMatrix *A,
                     hypre_ParVector    *f,
                     hypre_ParVector    *u,
                     HYPRE_Int *CF_marker,
                     HYPRE_Int rlx_pt)
{
   hypre_SchwarzData   *schwarz_data = (hypre_SchwarzData*) schwarz_vdata;

   hypre_CSRMatrix *domain_structure =
      hypre_SchwarzDataDomainStructure(schwarz_data);
   HYPRE_Real *scale = hypre_SchwarzDataScale(schwarz_data);
   hypre_ParVector *Vtemp = hypre_SchwarzDataVtemp(schwarz_data);
   HYPRE_Int variant = hypre_SchwarzDataVariant(schwarz_data);
   HYPRE_Real relax_wt = hypre_SchwarzDataRelaxWeight(schwarz_data);

   HYPRE_Int use_nonsymm = hypre_SchwarzDataUseNonSymm(schwarz_data);

   HYPRE_Int *pivots = hypre_SchwarzDataPivots(schwarz_data);

   if (variant == 1)
   {
      hypre_AdSchwarzCFSolve(A, f, domain_structure, scale, u, Vtemp,
                             CF_marker, rlx_pt, pivots, use_nonsymm);
   }
   else if (variant == 4)
   {
      hypre_MPSchwarzCFFWSolve(A, hypre_ParVectorLocalVector(f),
                               domain_structure, u, relax_wt,
                               hypre_ParVectorLocalVector(Vtemp),
                               CF_marker, rlx_pt, pivots, use_nonsymm);
   }
   else
   {
      hypre_MPSchwarzCFSolve(A, hypre_ParVectorLocalVector(f),
                             domain_structure, u, relax_wt,
                             hypre_ParVectorLocalVector(Vtemp),
                             CF_marker, rlx_pt, pivots, use_nonsymm);
   }

   return hypre_error_flag;
}

/*--------------------------------------------------------------------------
 * Routines to set various parameters
 *--------------------------------------------------------------------------*/

HYPRE_Int
hypre_SchwarzSetVariant( void *data, HYPRE_Int variant )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataVariant(schwarz_data) = variant;
   return hypre_error_flag;

}

HYPRE_Int
hypre_SchwarzSetDomainType( void *data, HYPRE_Int domain_type )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataDomainType(schwarz_data) = domain_type;
   return hypre_error_flag;

}

HYPRE_Int
hypre_SchwarzSetOverlap( void *data, HYPRE_Int overlap )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataOverlap(schwarz_data) = overlap;

   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzSetNumFunctions( void *data, HYPRE_Int num_functions )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataNumFunctions(schwarz_data) = num_functions;

   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzSetNonSymm( void *data, HYPRE_Int value )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataUseNonSymm(schwarz_data) = value;

   return hypre_error_flag;

}

HYPRE_Int
hypre_SchwarzSetRelaxWeight( void *data, HYPRE_Real relax_weight )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataRelaxWeight(schwarz_data) = relax_weight;

   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzSetDomainStructure( void *data, hypre_CSRMatrix *domain_structure )
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataDomainStructure(schwarz_data) = domain_structure;

   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzSetScale( void *data, HYPRE_Real *scale)
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataScale(schwarz_data) = scale;

   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzReScale( void *data, HYPRE_Int size, HYPRE_Real value)
{

   HYPRE_Int i;
   HYPRE_Real *scale;
   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   scale = hypre_SchwarzDataScale(schwarz_data);
   for (i = 0; i < size; i++)
   {
      scale[i] *= value;
   }

   return hypre_error_flag;

}

HYPRE_Int
hypre_SchwarzSetDofFunc( void *data, HYPRE_Int *dof_func)
{

   hypre_SchwarzData  *schwarz_data = (hypre_SchwarzData*) data;

   hypre_SchwarzDataDofFunc(schwarz_data) = dof_func;

   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzGetSetupFlops( void *data, HYPRE_Real *setup_flops )
{
   hypre_SchwarzData *schwarz_data = (hypre_SchwarzData *) data;
   *setup_flops = hypre_SchwarzDataSetupFlops(schwarz_data);
   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzGetSetupGraphOps( void *data, HYPRE_Real *setup_graph_ops )
{
   hypre_SchwarzData *schwarz_data = (hypre_SchwarzData *) data;
   *setup_graph_ops = hypre_SchwarzDataSetupGraphOps(schwarz_data);
   return hypre_error_flag;
}

HYPRE_Int
hypre_SchwarzGetApplyFlops( void *data, HYPRE_Real *apply_flops )
{
   hypre_SchwarzData *schwarz_data = (hypre_SchwarzData *) data;
   *apply_flops = hypre_SchwarzDataApplyFlops(schwarz_data);
   return hypre_error_flag;
}
